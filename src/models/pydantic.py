from datetime import datetime
from typing import List

from fastapi import HTTPException, status
from pydantic import BaseModel, Field, model_validator


class BenchmarkResult(BaseModel):
    request_id: str = Field(
        description="Unique identifier for the benchmarking request."
    )
    prompt_text: str = Field(description="The input prompt text used for the LLM.")
    generated_text: str = Field(description="The output text generated by the LLM.")
    token_count: int = Field(description="The number of tokens in the generated text.")
    time_to_first_token: int = Field(
        description="The time taken to generate the first token (in milliseconds)."
    )
    time_per_output_token: int = Field(
        description="The average time per output token (in milliseconds)."
    )
    total_generation_time: int = Field(
        description="The total time to generate the response (in milliseconds)."
    )
    timestamp: datetime = Field(
        description="The timestamp when the benchmarking result was recorded."
    )


class BenchmarkResultsBatch(BaseModel):
    benchmarking_results: List[BenchmarkResult]


class ResultsAverageResponseModel(BaseModel):
    average_token_count: float
    average_time_to_first_token: float
    average_time_per_output_token: float
    average_total_generation_time: float


class TimeRangeParams(BaseModel):
    start_time: datetime
    end_time: datetime

    @model_validator(mode="after")
    def validate_time_range(self) -> "TimeRangeParams":
        if self.start_time > self.end_time:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="start_time must be before or equal to end_time",
            )
        return self
